<?php

namespace App\Command;

use App\Entity\Security\Role;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Router;
use Symfony\Component\Routing\RouterInterface;
use Symfony\Component\Yaml\Yaml;
use Symfony\Contracts\Translation\TranslatorInterface;

class GenerateConfigurationCommand extends Command
{
    const DISPLAY_ACCESS_LIST = 'access-list';
    const DISPLAY_ROLE_HIERARCHY = 'role-hierarchy';

    const METHOD_UPDATE = 'update';
    const METHOD_RECREATE = 'recreate';

    protected static $defaultName = 'webslon:auth-bundle:generate-crud-roles';

    /** @var []string[string] */
    private $assoc;

    /** @var EntityManagerInterface */
    private EntityManagerInterface $entityManager;

    /** @var TranslatorInterface */
    private TranslatorInterface $translator;

    /** @var RouterInterface */
    private RouterInterface $router;

    public function __construct(EntityManagerInterface $entityManager, TranslatorInterface $translator, RouterInterface $router)
    {
        $this->entityManager = $entityManager;
        $this->translator = $translator;
        $this->router = $router;

        parent::__construct(self::$defaultName);
    }

    protected function configure()
    {
        parent::configure(); // TODO: Change the autogenerated stub

        $this->addOption('role-entity-class', 'r', InputOption::VALUE_REQUIRED, 'Entity class for role');
        $this->addOption('display', 'd', InputOption::VALUE_REQUIRED, '--display=access-list or --display=role-hierarchy');
        $this->addOption('entities', 'en', InputOption::VALUE_IS_ARRAY | InputOption::VALUE_REQUIRED, 'List entities');
        $this->addOption('method', 'm', InputOption::VALUE_REQUIRED, 'Method: "update" - update exists (default), "recreate" - delete exists and create new');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $method = trim($input->getOption('method')) ?? self::METHOD_UPDATE;
        if (!in_array($method, [self::METHOD_UPDATE, self::METHOD_RECREATE])) {
            throw new \RuntimeException(sprintf('Method should be %s or %s', self::METHOD_UPDATE, self::METHOD_RECREATE));
        }

        $routes = $this->router->getRouteCollection()->all();

        $hierarchy = ['ROLE_ROOT' => []];
        $allRoles = [];
        $accessList = [];

        $display = $input->getOption('display') ?: [];
        $displayAccessList = in_array(self::DISPLAY_ACCESS_LIST, $display) || !$display;
        $displayRoleHierarchy = in_array(self::DISPLAY_ROLE_HIERARCHY, $display) || !$display;
        $entities = $input->getOption('entities') ?: [];

        $rolesMap = [];

        /** @var Route $route */
        foreach ($routes as $route) {
            $controller = $route->getDefault('_controller');
            if (strpos($controller, '::') !== false) {
                $controllerInfo = explode('::', $controller);
                $methods = $route->getMethods();

                if ($methods && \defined($controllerInfo[0] . '::ENTITY_CLASS')) {
                    $entityClass = $controllerInfo[0]::ENTITY_CLASS;
                    if (!isset($rolesMap[$entityClass])) {
                        $rolesMap[$entityClass] = [];
                    }

                    if ($entities && !in_array($entityClass, $entities)) {
                        continue;
                    }

                    switch ($controllerInfo[1]) {
                        case 'getListAction':
                            $roles = ['READ'];
                            break;

                        case 'updateItemAction':
                        case 'patchItemAction':
                            $roles = ['UPDATE'];
                            break;

                        case 'deleteItemAction':
                            $roles = ['DELETE'];
                            break;

                        case 'addItemAction':
                            $roles = ['ADD'];
                            break;

                        default:
                            continue 2;
                    }

                    $formattedClass = $this->format($entityClass);
                    $requiredRoles = [];
                    foreach ($roles as $role) {
                        $roleFormat = 'ROLE_'.mb_strtoupper($role).'_'.$formattedClass;
                        if (!in_array('ROLE_WRITE_'.$formattedClass, $allRoles)) {
                            $allRoles[] = 'ROLE_WRITE_'.$formattedClass;
                        }
                        $requiredRoles[] = $roleFormat;
                        $allRoles[] = $roleFormat;
                        $rolesMap[$entityClass][] = $roleFormat;
                    }

                    $methods = $route->getMethods();
                    if ($methods[0] == 'PUT' && count($methods) == 1) {
                        $methods[] = 'PATCH';
                    }
                    if ($methods[0] == 'PATCH' && count($methods) == 1) {
                        $methods[] = 'PUT';
                    }

                    $accessList[] = sprintf(
                        '- { path: ^%s, roles: [%s], methods: [%s] }',
                        str_replace('{petId}', '*', str_replace('/{id}', '', $route->getPath())),
                        implode(',', $requiredRoles),
                        implode(',', $methods)
                    );
                }
            }
        }

        if ($displayRoleHierarchy) {
            $output->writeln('Иерархия ролей:');
            foreach ($allRoles as $requiredRole) {
                $roleInfo = explode('_', $requiredRole);
                $roleInfoTmp = $roleInfo;

                unset($roleInfoTmp[0], $roleInfoTmp[1]);
                $entityCode = implode('_', $roleInfoTmp);

                if ($roleInfo[1] == 'UPDATE' || $roleInfo[1] == 'ADD') {
                    $keyWrite = 'ROLE_WRITE_'.$entityCode;
                    $hierarchy[$keyWrite][] = $requiredRole;
                } else {
                    $keyEntity = 'ROLE_'.$entityCode;
                    $hierarchy[$keyEntity][] = 'ROLE_WRITE_'.$entityCode;

                    $hierarchy[$keyEntity][] = $requiredRole;
                    $hierarchy[$keyEntity] = array_values(array_unique($hierarchy[$keyEntity]));

                    $hierarchy['ROLE_ROOT'][] = $keyEntity;

                    if (!array_search('ROLE_WRITE_'.$entityCode, $allRoles)) {
                        $allRoles[] = 'ROLE_WRITE_'.$entityCode;
                    }

                    if (!array_search('ROLE_'.$entityCode, $allRoles)) {
                        $allRoles[] = 'ROLE_'.$entityCode;
                    }
                }
            }
            $hierarchy['ROLE_ROOT'] = array_unique($hierarchy['ROLE_ROOT']);

            $yml = Yaml::dump($hierarchy);

            $output->writeln(
                preg_replace('/[0-9]+:\ /', '', $yml)
            );
        }

        if ($displayAccessList) {
            $output->writeln('Access list конфигурация:');
            $output->writeln(
                implode(PHP_EOL, $accessList)
            );
        }

        if ($roleEntityClass = $input->getOption('role-entity-class')) {
            $repository = $this->entityManager->getRepository($roleEntityClass);

            foreach ($allRoles as $roleCode) {
                $prefixes = [
                    'ROLE_WRITE_' => 'Добавление + Обновление',
                    'ROLE_READ_' => 'Чтение',
                    'ROLE_ADD_' => 'Добавление',
                    'ROLE_UPDATE_' => 'Обновление',
                    'ROLE_DELETE_' => 'Удаление',
                    'ROLE_' => 'Полный доступ',
                ];

                $name = $roleCode;
                foreach ($prefixes as $prefix => $operationName) {
                    if (strpos($roleCode, $prefix) !== false) {
                        $entityCode = str_replace($prefix, '', $roleCode);
                        if ($assoc = $this->assoc[$entityCode]) {
                            $name = $assoc.' - '.$operationName;
                            break;
                        }
                    }
                }

                $roleFromDatabase = $repository->findOneBy(['code' => $roleCode]);

                if ($method === self::METHOD_RECREATE) {
                    if ($roleFromDatabase) {
                        $newRole = clone $roleFromDatabase;
                        $this->entityManager->remove($roleFromDatabase);
                        $this->entityManager->flush();

                        $newRole->setName($name);
                        $newRole->setCode($roleCode);
                        $this->entityManager->persist($newRole);
                    } else {
                        /** @var Role $role */
                        $role = new $roleEntityClass();
                        $role->setName($name);
                        $role->setCode($roleCode);

                        $this->entityManager->persist($role);
                    }
                } elseif ($method === self::METHOD_UPDATE) {
                    if ($roleFromDatabase) {
//                        $output->writeln(sprintf('Role %s already exists', $roleCode));
                        $roleFromDatabase->setName($name);
                        $this->entityManager->persist($roleFromDatabase);
                    } else {
                        $output->writeln(sprintf('Role %s is new role', $roleCode));
                        /** @var Role $role */
                        $role = new $roleEntityClass();
                        $role->setName($name);
                        $role->setCode($roleCode);

                        $this->entityManager->persist($role);
                    }
                }
            }

            $this->entityManager->flush();
        }
        return Command::SUCCESS;
    }

    public function format($entityClass)
    {
        $classInfo = explode('\\', $entityClass);
        $entityClass = array_pop($classInfo);

        $result = [];
        for ($i = 0; $i < strlen($entityClass); $i++) {
            $symbol = $entityClass[$i];
            if (mb_strtoupper($symbol) === $symbol) {
                $result[] = '_';
                $result[] = $symbol;
            } else {
                $result[] = $symbol;
            }
        }

        $entityCode = ltrim(rtrim(mb_strtoupper(implode('', $result)), '_'), '_');

        $entityClassData = explode('\\', $entityClass);
        $entityClassName = array_pop($entityClassData);

        $this->assoc[$entityCode] = $this->translator->trans($entityClassName, [], 'classes', 'ru');

        return $entityCode;
    }
}
