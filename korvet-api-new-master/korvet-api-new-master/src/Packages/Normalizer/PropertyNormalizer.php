<?php

namespace App\Packages\Normalizer;

use LogicException;
use Symfony\Component\Serializer\Normalizer\PropertyNormalizer as SymfonyPropertyNormalizer;
use Symfony\Component\Serializer\SerializerInterface;

use Symfony\Component\PropertyAccess\PropertyAccess;

class PropertyNormalizer extends SymfonyPropertyNormalizer
{
    /**
     * @var SerializerInterface
     */
    protected $serializer;

    public function setSerializer($serializer)
    {
        $this->serializer = $serializer;
    }

    /**
     * @param $object
     * @param $attribute
     * @param null $format
     * @param array $context
     * @return mixed
     */
    protected function getAttributeValue($object, $attribute, $format = null, array $context = array())
    {
        if (class_exists('\Symfony\Component\PropertyAccess\PropertyAccess')) {
            $propertyAccessor = \Symfony\Component\PropertyAccess\PropertyAccess::createPropertyAccessor();
            if ($propertyAccessor->isReadable($object, $attribute)) {
                return $propertyAccessor->getValue($object, $attribute);
            }
        }
        

        return parent::getAttributeValue($object, $attribute, $format, $context);
    }

    /**
     * @param object $object
     * @param null $format
     * @param array $context
     * @return array|string[]
     */
    protected function extractAttributes($object, $format = null, array $context = array()): array
    {
        $reflectionObject = new \ReflectionObject($object);
        $attributes = array();

        do {
            foreach ($reflectionObject->getProperties() as $property) {
                if (!$this->isAllowedAttribute($reflectionObject->getName(), $property->name, $format, $context)) {
                    continue;
                }

                $attributes[] = $property->name;
            }
        } while ($reflectionObject = $reflectionObject->getParentClass());

        return $attributes;
    }

    /**
     * @param $classOrObject
     * @param $attribute
     * @param null $format
     * @param array $context
     * @return bool
     */
    protected function isAllowedAttribute($classOrObject, $attribute, $format = null, array $context = []): bool
    {
        if (isset($context['amqp']) && $context['amqp']) {
            foreach ($this->classMetadataFactory->getMetadataFor($classOrObject)->getAttributesMetadata() as $attributeMetadata) {
                if ($attributeMetadata->getName() == $attribute) {
                    $groups = $attributeMetadata->getGroups() ?? [];
                    if (in_array('amqp.expose', $groups)) {
                        return false;
                    }
                }
            }
        }
        foreach ($this->classMetadataFactory->getMetadataFor($classOrObject)->getAttributesMetadata() as $attributeMetadata) {
            if ($attributeMetadata->getName() == $attribute) {
                $groups = $attributeMetadata->getGroups() ?? [];
                if (in_array('expose', $groups)) {
                    return false;
                }
            }
        }
        return parent::isAllowedAttribute($classOrObject, $attribute, $format, $context); // TODO: Change the autogenerated stub
    }

    protected function getAllowedAttributes($classOrObject, array $context, $attributesAsString = false)
    {
        if (!$this->classMetadataFactory) {
            if (isset($context[static::ALLOW_EXTRA_ATTRIBUTES]) && !$context[static::ALLOW_EXTRA_ATTRIBUTES]) {
                throw new LogicException(sprintf('A class metadata factory must be provided in the constructor when setting "%s" to false.', static::ALLOW_EXTRA_ATTRIBUTES));
            }

            return false;
        }

        $groups = false;
        if (isset($context[static::GROUPS]) && \is_array($context[static::GROUPS])) {
            $groups = $context[static::GROUPS];
        } elseif (!isset($context[static::ALLOW_EXTRA_ATTRIBUTES]) || $context[static::ALLOW_EXTRA_ATTRIBUTES]) {
            return false;
        }

        $allowedAttributes = array();
        foreach ($this->classMetadataFactory->getMetadataFor($classOrObject)->getAttributesMetadata() as $attributeMetadata) {
            $name = $attributeMetadata->getName();

            $expectedPermissionGroups = $actualPermissionGroups = [];
            foreach ($attributeMetadata->getGroups() as $group) {
                if ('permission.' === substr($group, 0, 11)) {
                    $expectedPermissionGroups[] = $group;
                }
            }

            foreach ($groups as $group) {
                if ('permission.' === substr($group, 0, 11)) {
                    $actualPermissionGroups[] = $group;
                }
            }
            $intersect = array_intersect($expectedPermissionGroups, $actualPermissionGroups);
            $hasRoleRoot = array_search('permission.root', $actualPermissionGroups) !== false;
            $access = $hasRoleRoot || $intersect || empty($expectedPermissionGroups);

            $exposeGroup = isset($context['amqp']) && $context['amqp'] ? 'amqp.expose' : 'expose';
            $expose = array_search($exposeGroup, $attributeMetadata->getGroups()) !== false;
            if (
                $access &&
                !$expose &&
                (false === $groups || array_intersect($attributeMetadata->getGroups(), $groups) || !$attributeMetadata->getGroups()) &&
                $this->isAllowedAttribute($classOrObject, $name, null, $context)
            ) {
                $allowedAttributes[] = $attributesAsString ? $name : $attributeMetadata;
            }
        }
        
        return $allowedAttributes;
    }
}
